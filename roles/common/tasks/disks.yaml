---
# Dynamic disk discovery and setup
# Finds all non-root block devices and assigns them based on size:
# - Largest: rollup_storage_dir
# - Second largest: logs
# - Third largest: da_store (only if data_availability_role is mock_da)

- name: discover root device
  shell: |
    lsblk -ndo NAME,MOUNTPOINT,TYPE | \
    awk '$2=="/" && $3=="disk" {print $1}'
  register: root_device_raw
  changed_when: false
  become: true

- name: discover all non-root block devices
  shell: |
    root_dev="{{ root_device_raw.stdout }}"
    lsblk -ndo NAME,SIZE,TYPE | \
    awk -v root="$root_dev" '$3=="disk" && $1!=root {print $2,$1}' | \
    sort -hr | \
    awk '{print $2}'
  register: available_devices_raw
  changed_when: false
  become: true

- name: parse available devices list
  set_fact:
    available_devices: "{{ available_devices_raw.stdout_lines }}"

- name: set disk assignments
  set_fact:
    largest_disk: "{{ available_devices[0] | default('') }}"
    second_largest_disk: "{{ available_devices[1] | default('') }}"
    third_largest_disk: "{{ available_devices[2] | default('') }}"

- name: print disk discovery results
  debug:
    msg:
      - "Found {{ available_devices | length }} non-root block device(s)"
      - "Largest disk: {{ largest_disk if largest_disk else 'None - rollup_storage_dir will use root volume' }}"
      - "Second largest disk: {{ second_largest_disk if second_largest_disk else 'None - logs will use root volume' }}"
      - "Third largest disk: {{ third_largest_disk if third_largest_disk else 'None - da_store will use root volume' }}"
      - "Reformat disks: {{ reformat_disks | default(false) }}"
      - "DA setup: {{ 'Using third disk for local mock_da' if (third_largest_disk != '' and data_availability_role == 'mock_da' and mock_da_external_url is not defined) else ('Using external mock_da - no disk needed' if (data_availability_role == 'mock_da' and mock_da_external_url is defined) else 'Not using mock_da') }}"

# Setup largest disk for rollup_storage_dir
- name: check if largest disk has filesystem
  shell: blkid -s TYPE -o value /dev/{{ largest_disk }} || echo "none"
  register: largest_disk_fstype
  changed_when: false
  become: true
  when: largest_disk != ''

- name: unmount largest disk if reformat requested
  mount:
    path: "{{ rollup_storage_dir }}"
    state: unmounted
  become: true
  when:
    - largest_disk != ''
    - reformat_disks | default(false)
    - largest_disk_fstype.stdout != 'none'

- name: format largest disk with ext4
  filesystem:
    fstype: ext4
    dev: "/dev/{{ largest_disk }}"
    force: "{{ reformat_disks | default(false) }}"
  become: true
  when:
    - largest_disk != ''
    - largest_disk_fstype.stdout == 'none' or (reformat_disks | default(false))

- name: get UUID of largest disk
  command: blkid -s UUID -o value /dev/{{ largest_disk }}
  register: largest_disk_uuid
  changed_when: false
  become: true
  when: largest_disk != ''

- name: ensure rollup_storage_dir is mounted
  mount:
    path: "{{ rollup_storage_dir }}"
    src: "UUID={{ largest_disk_uuid.stdout }}"
    fstype: ext4
    opts: "noatime,nodiratime"
    state: mounted
  become: true
  when: largest_disk != ''

- name: set sovereign ownership on rollup_storage_dir
  file:
    path: "{{ rollup_storage_dir }}"
    state: directory
    owner: sovereign
    group: sovereign
  become: true

# Setup second largest disk for logs
- name: check if second largest disk has filesystem
  shell: blkid -s TYPE -o value /dev/{{ second_largest_disk }} || echo "none"
  register: second_largest_disk_fstype
  changed_when: false
  become: true
  when: second_largest_disk != ''

- name: unmount second largest disk if reformat requested
  mount:
    path: "{{ rollup_log_dir }}"
    state: unmounted
  become: true
  when:
    - second_largest_disk != ''
    - reformat_disks | default(false)
    - second_largest_disk_fstype.stdout != 'none'

- name: format second largest disk with ext4
  filesystem:
    fstype: ext4
    dev: "/dev/{{ second_largest_disk }}"
    force: "{{ reformat_disks | default(false) }}"
  become: true
  when:
    - second_largest_disk != ''
    - second_largest_disk_fstype.stdout == 'none' or (reformat_disks | default(false))

- name: get UUID of second largest disk
  command: blkid -s UUID -o value /dev/{{ second_largest_disk }}
  register: second_largest_disk_uuid
  changed_when: false
  become: true
  when: second_largest_disk != ''

- name: ensure rollup_log_dir is mounted
  mount:
    path: "{{ rollup_log_dir }}"
    src: "UUID={{ second_largest_disk_uuid.stdout }}"
    fstype: ext4
    opts: "noatime,nodiratime"
    state: mounted
  become: true
  when: second_largest_disk != ''

- name: set sovereign ownership on rollup_log_dir
  file:
    path: "{{ rollup_log_dir }}"
    state: directory
    owner: sovereign
    group: sovereign
  become: true

# Setup third largest disk for da_store (only if mock_da and not using external mock_da)
- name: check if third disk should be used for da_store
  set_fact:
    use_third_disk_for_da: "{{ third_largest_disk != '' and data_availability_role == 'mock_da' and mock_da_external_url is not defined }}"

- name: check if third largest disk has filesystem
  shell: blkid -s TYPE -o value /dev/{{ third_largest_disk }} || echo "none"
  register: third_largest_disk_fstype
  changed_when: false
  become: true
  when: use_third_disk_for_da

- name: unmount third largest disk if reformat requested
  mount:
    path: "{{ da_store }}"
    state: unmounted
  become: true
  when:
    - use_third_disk_for_da
    - reformat_disks | default(false)
    - third_largest_disk_fstype.stdout != 'none'

- name: format third largest disk with ext4
  filesystem:
    fstype: ext4
    dev: "/dev/{{ third_largest_disk }}"
    force: "{{ reformat_disks | default(false) }}"
  become: true
  when:
    - use_third_disk_for_da
    - third_largest_disk_fstype.stdout == 'none' or (reformat_disks | default(false))

- name: get UUID of third largest disk
  command: blkid -s UUID -o value /dev/{{ third_largest_disk }}
  register: third_largest_disk_uuid
  changed_when: false
  become: true
  when: use_third_disk_for_da

- name: ensure da_store is mounted
  mount:
    path: "{{ da_store }}"
    src: "UUID={{ third_largest_disk_uuid.stdout }}"
    fstype: ext4
    opts: "noatime,nodiratime"
    state: mounted
  become: true
  when: use_third_disk_for_da

- name: set sovereign ownership on da_store
  file:
    path: "{{ da_store }}"
    state: directory
    owner: sovereign
    group: sovereign
  become: true
