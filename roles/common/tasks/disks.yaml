---
# Dynamic disk discovery and setup
# Finds all non-root block devices and assigns them based on size:
# - Largest: rollup_storage_dir
# - Second largest: logs
# - Third largest: da_store (only if da_role is mock_da)

- name: discover system disks (disks containing /, /boot, /boot/efi partitions)
  shell: |
    # Find all disks that contain system partitions
    lsblk -nrpo NAME,MOUNTPOINT,TYPE | \
    awk '$3=="part" && ($2=="/" || $2=="/boot" || $2=="/boot/efi" || $2=="/boot/grub") {
      disk=$1
      # Handle NVMe naming (nvme0n1p1 -> nvme0n1)
      if (match(disk, /nvme[0-9]+n[0-9]+p[0-9]+$/)) {
        sub(/p[0-9]+$/, "", disk)
      }
      # Handle standard naming (sda1 -> sda, xvda1 -> xvda)
      else {
        sub(/[0-9]+$/, "", disk)
      }
      # Remove /dev/ prefix for consistency
      sub(/^\/dev\//, "", disk)
      print disk
    }' | sort -u
  register: system_disks_raw
  changed_when: false
  become: true

- name: discover all non-system block devices
  shell: |
    # Get system disks as a pattern for exclusion
    system_disks="{{ system_disks_raw.stdout_lines | join('|') }}"
    if [ -z "$system_disks" ]; then
      system_disks="^$"  # Match nothing if no system disks found
    fi
    # List all disks, exclude system disks, sort by size descending
    lsblk -ndo NAME,SIZE,TYPE | \
    awk -v exclude="$system_disks" '$3=="disk" && $1 !~ exclude {print $2,$1}' | \
    sort -hr | \
    awk '{print $2}'
  register: available_devices_raw
  changed_when: false
  become: true

- name: parse available devices list
  set_fact:
    available_devices: "{{ available_devices_raw.stdout_lines }}"

- name: set disk assignments
  set_fact:
    largest_disk: "{{ available_devices[0] | default('') }}"
    second_largest_disk: "{{ available_devices[1] | default('') }}"
    third_largest_disk: "{{ available_devices[2] | default('') }}"

- name: print disk discovery results
  debug:
    msg:
      - "System disks (excluded): {{ system_disks_raw.stdout_lines | join(', ') if system_disks_raw.stdout_lines else 'None detected' }}"
      - "Found {{ available_devices | length }} available data disk(s)"
      - "Largest disk: {{ largest_disk if largest_disk else 'None - rollup_storage_dir will use root volume' }}"
      - "Second largest disk: {{ second_largest_disk if second_largest_disk else 'None - logs will use root volume' }}"
      - "Third largest disk: {{ third_largest_disk if third_largest_disk else 'None - da_store will use root volume' }}"
      - "Reformat disks: {{ reformat_disks | default(false) }}"
      - "DA setup: {{ 'Using third disk for local mock_da' if ((available_devices | length >= 3) and da_role == 'mock_da' and mock_da_external_url is not defined) else ('Using external mock_da - no disk needed' if (da_role == 'mock_da' and mock_da_external_url is defined) else ('mock_da enabled but no third disk available' if (da_role == 'mock_da') else 'Not using mock_da')) }}"

# Setup largest disk for rollup_storage_dir (requires at least 1 disk)
- name: check if largest disk has filesystem
  shell: blkid -s TYPE -o value /dev/{{ largest_disk }} || echo "none"
  register: largest_disk_fstype
  changed_when: false
  become: true
  when: available_devices | length >= 1

- name: unmount largest disk if reformat requested
  mount:
    path: "{{ rollup_storage_dir }}"
    state: unmounted
  become: true
  when:
    - available_devices | length >= 1
    - reformat_disks | default(false)
    - largest_disk_fstype.stdout != 'none'

- name: format largest disk with ext4
  filesystem:
    fstype: ext4
    dev: "/dev/{{ largest_disk }}"
    force: "{{ reformat_disks | default(false) }}"
  become: true
  when:
    - available_devices | length >= 1
    - largest_disk_fstype.stdout == 'none' or (reformat_disks | default(false))

- name: get UUID of largest disk
  command: blkid -s UUID -o value /dev/{{ largest_disk }}
  register: largest_disk_uuid
  changed_when: false
  become: true
  when: available_devices | length >= 1

- name: ensure rollup_storage_dir is mounted
  mount:
    path: "{{ rollup_storage_dir }}"
    src: "UUID={{ largest_disk_uuid.stdout }}"
    fstype: ext4
    opts: "noatime,nodiratime"
    state: mounted
  become: true
  when: available_devices | length >= 1

- name: set sovereign ownership on rollup_storage_dir
  file:
    path: "{{ rollup_storage_dir }}"
    state: directory
    owner: sovereign
    group: sovereign
  become: true

# Setup second largest disk for logs (requires at least 2 disks)
- name: check if second largest disk has filesystem
  shell: blkid -s TYPE -o value /dev/{{ second_largest_disk }} || echo "none"
  register: second_largest_disk_fstype
  changed_when: false
  become: true
  when: available_devices | length >= 2

- name: unmount second largest disk if reformat requested
  mount:
    path: "{{ rollup_log_dir }}"
    state: unmounted
  become: true
  when:
    - available_devices | length >= 2
    - reformat_disks | default(false)
    - second_largest_disk_fstype.stdout != 'none'

- name: format second largest disk with ext4
  filesystem:
    fstype: ext4
    dev: "/dev/{{ second_largest_disk }}"
    force: "{{ reformat_disks | default(false) }}"
  become: true
  when:
    - available_devices | length >= 2
    - second_largest_disk_fstype.stdout == 'none' or (reformat_disks | default(false))

- name: get UUID of second largest disk
  command: blkid -s UUID -o value /dev/{{ second_largest_disk }}
  register: second_largest_disk_uuid
  changed_when: false
  become: true
  when: available_devices | length >= 2

- name: ensure rollup_log_dir is mounted
  mount:
    path: "{{ rollup_log_dir }}"
    src: "UUID={{ second_largest_disk_uuid.stdout }}"
    fstype: ext4
    opts: "noatime,nodiratime"
    state: mounted
  become: true
  when: available_devices | length >= 2

- name: set sovereign ownership on rollup_log_dir
  file:
    path: "{{ rollup_log_dir }}"
    state: directory
    owner: sovereign
    group: sovereign
  become: true

# Setup third largest disk for da_store (only if mock_da, not using external mock_da, AND we have 3+ disks)
- name: check if third disk should be used for da_store
  set_fact:
    use_third_disk_for_da: "{{ (available_devices | length >= 3) and da_role == 'mock_da' and mock_da_external_url is not defined }}"

- name: check if third largest disk has filesystem
  shell: blkid -s TYPE -o value /dev/{{ third_largest_disk }} || echo "none"
  register: third_largest_disk_fstype
  changed_when: false
  become: true
  when: use_third_disk_for_da

- name: unmount third largest disk if reformat requested
  mount:
    path: "{{ da_store }}"
    state: unmounted
  become: true
  when:
    - use_third_disk_for_da
    - reformat_disks | default(false)
    - third_largest_disk_fstype.stdout != 'none'

- name: format third largest disk with ext4
  filesystem:
    fstype: ext4
    dev: "/dev/{{ third_largest_disk }}"
    force: "{{ reformat_disks | default(false) }}"
  become: true
  when:
    - use_third_disk_for_da
    - third_largest_disk_fstype.stdout == 'none' or (reformat_disks | default(false))

- name: get UUID of third largest disk
  command: blkid -s UUID -o value /dev/{{ third_largest_disk }}
  register: third_largest_disk_uuid
  changed_when: false
  become: true
  when: use_third_disk_for_da

- name: ensure da_store is mounted
  mount:
    path: "{{ da_store }}"
    src: "UUID={{ third_largest_disk_uuid.stdout }}"
    fstype: ext4
    opts: "noatime,nodiratime"
    state: mounted
  become: true
  when: use_third_disk_for_da

- name: set sovereign ownership on da_store
  file:
    path: "{{ da_store }}"
    state: directory
    owner: sovereign
    group: sovereign
  become: true
  when: use_third_disk_for_da
